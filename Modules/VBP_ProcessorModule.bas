Attribute VB_Name = "Processor"
'***************************************************************************
'Program Sub-Processor and Error Handler
'Copyright 2001-2015 by Tanner Helland
'Created: 4/15/01
'Last updated: 06/May/15
'Last update: new functions for processing non-destructive changes
'
'Module for controlling calls to the various program functions.  Any action the program takes has to pass
' through here.  Why go to all that extra work?  A couple of reasons:
' 1) a central error handler
' 2) PhotoDemon can run macros by simply tracking the values that pass through this routine
' 3) PhotoDemon can control code flow by delaying requests that pass through here (for example,
'    if the program is busy applying a filter, we can wait to process subsequent calls)
' 4) miscellaneous semantic benefits
'
'Due to the nature of this routine, very little of interest happens here - this is primarily a router
' for various functions, so the majority of the routine is a huge Case Select statement.
'
'All source code in this file is licensed under a modified BSD license.  This means you may use the code in your own
' projects IF you provide attribution.  For more information, please visit http://photodemon.org/about/license/
'
'***************************************************************************

Option Explicit
Option Compare Text

'Data type for tracking processor calls - used for macros (NOTE: this is the 2013 model; older models are no longer supported.)
Public Type ProcessCall
    Id As String
    Dialog As Boolean
    Parameters As String
    MakeUndo As PD_UNDO_TYPE
    Tool As Long
    Recorded As Boolean
End Type

'During macro recording, all requests to the processor are stored in this array.
Public Processes() As ProcessCall

'How many processor requests we currently have stored.
Public ProcessCount As Long

'Full processor information of the previous request (used to provide a "Repeat Last Action" feature)
Public LastProcess As ProcessCall

'Track processing (e.g. whether or not the actual Processor() function is running right now)
Private m_Processing As Boolean

'Elapsed time of this processor request (to enable this, see the top constant in the Public_Constants module)
Private m_ProcessingTime As Double

'Prior to initiating a (potentially) lengthy process, PD notes the window with keyboard input, then forcibly locks down input.
' After the action completes, keyboard focus is restored to its proper place.
Private m_FocusHWnd As Long

'To help track of control values tied to non-destructive effects, these values are generated by the FlagInitialNDFXState_XYZ functions.
' The corresponding FlagFinalNDFXState_XYZ functions will compare these values, and generate Undo and Macro data as necessary.
'
'Note that handling is broken out by type, as this is how pdLayer handles it (e.g. setting a non-destructive generic layer property
' uses a different wrapper function from non-destructive text layer properties).
'
'Also: note that the seemingly arbitrary array sizes match the number of unique entries in the various PDLAYER_XYZ_PROPERTY enums.
' Any changes to those enums *must be mirrored here*.
Private Const NUM_OF_GENERIC_PROPERTY_ENUMS As Long = 14
Private prevGenericLayerID As Long, prevGenericSetting() As Variant

Private Const NUM_OF_TEXT_PROPERTY_ENUMS As Long = 44
Private prevTextLayerID As Long, prevTextSetting() As Variant

Private Const NUM_OF_NDFX_PROPERTY_ENUMS As Long = 6
Private prevNDFXLayerID As Long, prevNDFXSetting() As Variant


'PhotoDemon's software processor.  (Almost) every action the program takes is first routed through this method.  This processor is what
' makes recording and playing back macros possible, as well as a host of other features.  (See comment at top of page for more details.)
'
'INPUTS (asterisks denote optional parameters):
' - processID: a string identifying the action to be performed, e.g. "Blur"
' - *showDialog: some functions can be run with or without a dialog; for example, "Blur", "True" will display a blur settings dialog,
'                while "Blur", "False" will actually apply the blur.  When showDialog is true, Undo data is *not* created.
' - *processParameters: all parameters for this function, concatenated into a single string.  The processor will automatically parse out
'                       individual parameters as necessary.
' - *createUndo: ID describing what kind of Undo entry to create for this action.  This value is set to "do not create Undo" by default,
'                which is an important deviation from past PD versions.  *ANY ACTION THAT REQUIRES UNDO DATA CREATION MUST SPECIFICALLY
'                REQUEST CREATION OF SAID DATA.*  I have chosen to make Undo creation explicit, as part of a much more performance- and
'                memory-efficient Undo implementation.  NOTE: if showDialog is TRUE, this value will automatically be set to UNDO_NOTHING,
'                which means "DO NOT CREATE UNDO", because we never create Undo data when showing a dialog (as the user may cancel said
'                dialog).
' - *relevantTool: some Process calls are initiated by a particular tool (for example, "create selection" will be called by one of the
'                  selection tools).  This parameter can contain the relevant tool for a given action.  If Undo is used to return to a
'                  previous state, the relevant tool can automatically be selected, making it much easier for the user to make changes
'                  to an action using the proper tool.
' - *recordAction: are macros allowed to record this action?  Actions are assumed to be recordable.  However, some PhotoDemon functions
'                  are actually several actions strung together; when these are used, subsequent actions are marked as "not recordable"
'                  to prevent them from being executed twice.
Public Sub Process(ByVal processID As String, Optional showDialog As Boolean = False, Optional processParameters As String = "", Optional createUndo As PD_UNDO_TYPE = UNDO_NOTHING, Optional relevantTool As Long = -1, Optional recordAction As Boolean = True)

    'Main error handler for the software processor is initialized by this line
    On Error GoTo MainErrHandler
        
    'If we are applying an action to the image (e.g. not just showing a dialog), and the action is likely to take awhile
    ' (e.g. it is processing an image, and not just modifying a layer header) display a busy cursor.
    If (Not showDialog) Then
        If (createUndo = UNDO_EVERYTHING) Or (createUndo = UNDO_IMAGE) Or (createUndo = UNDO_IMAGE_VECTORSAFE) Or (createUndo = UNDO_LAYER) Then Screen.MousePointer = vbHourglass
    End If
    
    'Up front, create a parameter parser to handle the parameter string.  This can parse out individual function parameters as specific
    ' data types as necessary.  (Some pre-processing steps require parameter knowledge.)
    '
    'Note that at present, I am migrating all parameter strings to a new XML-based format.  As such, there are two
    ' param string processors running in parallel here.  cParams is due for deprecation as soon as that work finishes.
    Dim cParams As pdParamString
    Set cParams = New pdParamString
    If Len(processParameters) <> 0 Then cParams.setParamString processParameters
    
    Dim cXMLParams As pdParamXML
    Set cXMLParams = New pdParamXML
    If Len(processParameters) <> 0 Then cXMLParams.setParamString processParameters
    
    'This central processor is a convenient place to check for any hot-patches that may have occurred in the background.
    
    'Notify the live language updater that it is free to apply an immediate refresh.  (It will have already determined if any internals need to be
    ' updated to match various update processes, so there is no performance penalty if hot-patches are not required.)
    ' (Additionally, note that language files must be patched PRIOR to the main form being disabled; if we don't do this, interface items won't
    '  update correctly.)
    If (MacroStatus <> MacroBATCH) Then
        
        'Hot-patch the currently active language
        If Not (g_Language Is Nothing) Then g_Language.refreshAsRequired
    
    End If
    
    'PD provides two failsafes to avoid unwanted user interaction during processing. First, we forcibly remove keyboard focus from the thread.
    m_FocusHWnd = g_WindowManager.GetFocusAPI
    g_WindowManager.SetFocusAPI 0
    
    'With focus removed from any valid objects, now is a good time to mark the software processor as busy
    ' (but only when we're not showing a dialog!)
    If Not showDialog Then m_Processing = True
    
    'Next, complete part two of our "unwanted user interaction" failsafe: disable the main form to prevent the user from clicking additional
    ' menus or tools while this action is processing
    FormMain.Enabled = False
        
    #If DEBUGMODE = 1 Then
        If showDialog Then
            pdDebug.LogAction "Show """ & processID & """ dialog", PDM_PROCESSOR
        Else
            pdDebug.LogAction """" & processID & """: " & processParameters, PDM_PROCESSOR
        End If
    #End If
        
    'If we are simply repeating the last command, replace all the method parameters (which will be blank) with data from the
    ' LastEffectsCall object; this simple approach lets us repeat the last action effortlessly!
    If processID = "Repeat last action" Then
        processID = LastProcess.Id
        showDialog = LastProcess.Dialog
        processParameters = LastProcess.Parameters
        createUndo = LastProcess.MakeUndo
        relevantTool = LastProcess.Tool
        recordAction = LastProcess.Recorded
    End If
    
    'If the current layer is a vector layer, and the requested operation is *not* vector-safe, raise a rasterization warning.
    ' This gives the user a chance to back out before permanently ruining the layer.  (Note that the raised dialog offers a "remember
    ' my choice" setting, which the user can use to avoid this step entirely.)
    '
    '(Also: if this is a showDialog operation, we skip this step, so the user can play around without being bombarded by
    ' rasterization prompts.)
    '
    'Obviously, we skip this step if no images are loaded
    
    Dim i As Long
    
    If g_OpenImageCount > 0 Then
    
        Dim okayToRasterize As VbMsgBoxResult
        okayToRasterize = vbCancel
        
        'First, check for the case of operations that modify an entire image (e.g. "Flatten").  Three criteria must be met:
        ' 1) No dialog is being shown
        ' 2) The current layer must contain one or more vector layers
        ' 3) The Undo type must be UNDO_IMAGE or UNDO_EVERYTHING.  Header-only Undo operations do not require rasterization.
        Dim rasterizeImagePromptNeeded As Boolean
        rasterizeImagePromptNeeded = (Not showDialog)
        rasterizeImagePromptNeeded = rasterizeImagePromptNeeded And (pdImages(g_CurrentImage).getNumOfVectorLayers > 0)
        rasterizeImagePromptNeeded = rasterizeImagePromptNeeded And ((createUndo = UNDO_IMAGE) Or (createUndo = UNDO_EVERYTHING))
        
        'A few exceptions exist to the above code.  Layer merge operations typically require us to make a full Undo/Redo copy of the
        ' entire image stack, meeting the above criteria, but note that we only need to display a rasterize prompt if one or more of
        ' the *merged layers* are vector layers.  (Merging two image layers in an image with other vector layers shouldn't display a prompt.)
        If rasterizeImagePromptNeeded And ((processID = "Merge layer down") Or (processID = "Merge layer up") Or (processID = "Merge visible layers")) Then
            
            'For each case, determine if a vector layer is being merged, and if not, reset rasterizeImagePromptNeeded
            Select Case processID
            
                Case "Merge layer down"
                    If pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1)).isLayerRaster And pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1) - 1).isLayerRaster Then
                        rasterizeImagePromptNeeded = False
                    End If
                
                Case "Merge layer up"
                    If pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1)).isLayerRaster And pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1) + 1).isLayerRaster Then
                        rasterizeImagePromptNeeded = False
                    End If
                
                Case "Merge visible layers"
                    
                    rasterizeImagePromptNeeded = False
                    For i = 1 To pdImages(g_CurrentImage).getNumOfLayers - 1
                        
                        'If a vector layer is found, restore rasterizeImagePromptNeeded and exit the loop
                        If pdImages(g_CurrentImage).getLayerByIndex(i).getLayerVisibility And pdImages(g_CurrentImage).getLayerByIndex(i).isLayerVector Then
                            rasterizeImagePromptNeeded = True
                            Exit For
                        End If
                    
                    Next i
            
            End Select
            
        End If
        
        If rasterizeImagePromptNeeded Then
            
            okayToRasterize = Layer_Handler.askIfOkayToRasterizeLayer(pdImages(g_CurrentImage).getActiveLayer.getLayerType, , True)
            
            'If rasterization is okay, immediately apply it to all relevant layers
            If okayToRasterize = vbYes Then
                
                Select Case processID
                    
                    'When merging layers, only the merged layers need to be rasterized
                    Case "Merge layer down"
                        If pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1)).isLayerVector Then Layer_Handler.RasterizeLayer cParams.GetLong(1)
                        If pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1) - 1).isLayerVector Then Layer_Handler.RasterizeLayer cParams.GetLong(1) - 1
                        
                    Case "Merge layer up"
                        If pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1)).isLayerVector Then Layer_Handler.RasterizeLayer cParams.GetLong(1)
                        If pdImages(g_CurrentImage).getLayerByIndex(cParams.GetLong(1) + 1).isLayerVector Then Layer_Handler.RasterizeLayer cParams.GetLong(1) + 1
                    
                    Case "Merge visible layers"
                        For i = 1 To pdImages(g_CurrentImage).getNumOfLayers - 1
                            If pdImages(g_CurrentImage).getLayerByIndex(i).getLayerVisibility And pdImages(g_CurrentImage).getLayerByIndex(i).isLayerVector Then
                                Layer_Handler.RasterizeLayer i
                            End If
                        Next i
                        
                    'For any other case, rasterize all vector layers
                    Case Else
                        Layer_Handler.RasterizeLayer -1
                    
                End Select
                
            'If the user doesn't want rasterization, bail immediately.
            Else
                
                'Reset default tracking values and/or UI states prior to exiting
                m_Processing = False
                Screen.MousePointer = vbDefault
                FormMain.Enabled = True
                
                Exit Sub
                
            End If
            
        End If
        
        'Next, if this operation modifies just one layer, raise a "rasterize single layer" dialog.
        ' (Note that we skip this step if we already rasterized all layers, above.)
        If Not rasterizeImagePromptNeeded Then
            
            rasterizeImagePromptNeeded = (Not showDialog)
            rasterizeImagePromptNeeded = rasterizeImagePromptNeeded And pdImages(g_CurrentImage).getActiveLayer.isLayerVector
            rasterizeImagePromptNeeded = rasterizeImagePromptNeeded And CBool(createUndo = UNDO_LAYER)
            
            'Previously, I also checked for "(createUndo = UNDO_IMAGE) Or (createUndo = UNDO_EVERYTHING)" but I no longer think this
            ' is necessary, as those cases should have been covered by the previous check (which rasterizes *all* vector layers as necessary).
            
            'Display a prompt as necessary
            If rasterizeImagePromptNeeded Then
                
                okayToRasterize = Layer_Handler.askIfOkayToRasterizeLayer(pdImages(g_CurrentImage).getActiveLayer.getLayerType)
                
                'If rasterization is okay, apply it immediately
                If okayToRasterize = vbYes Then
                
                    Layer_Handler.RasterizeLayer pdImages(g_CurrentImage).getActiveLayerIndex
                
                'If the user doesn't want rasterization, bail immediately.
                Else
                    
                    'Reset default tracking values and/or UI states prior to exiting
                    m_Processing = False
                    Screen.MousePointer = vbDefault
                    FormMain.Enabled = True
                    
                    Exit Sub
                    
                End If
                
            End If
            
        End If
        
    End If
    
    'If a selection is active, certain functions (primarily transformations) will remove it before proceeding. This is typically
    ' done by functions that resize or reorient the image in a way that makes the selection's shape irrelevant. Because PD requires
    ' the selection mask and image size to remain in sync, errors may occur if selections persist after a size change - and this is
    ' particularly relevant for the Undo/Redo engine, because it will crash if it attempts to load an Undo file of an image, and the
    ' image size is not the same as the current selection assumes.
    '
    'Anyway, before moving deeper into the processor, we must check for actions that disallow selections, and prior to processing them,
    ' initiate a Remove Selection process request.
    If (Not showDialog) And (Not pdImages(g_CurrentImage) Is Nothing) Then
    
        'Only worry about this if a selection is actually active
        If pdImages(g_CurrentImage).selectionActive And (createUndo <> UNDO_SELECTION) Then
    
            Dim removeSelectionInAdvance As Boolean
            removeSelectionInAdvance = False
            
            'If this action reorients or resizes the image, mark the selection for removal
            Select Case processID
            
                Case "Resize image", "Resize", "Content-aware image resize", "Canvas size"
                    removeSelectionInAdvance = True
                    
                Case "Fit canvas to layer", "Fit canvas to all layers", "Trim empty borders"
                    removeSelectionInAdvance = True
                    
                Case "Rotate image 90 clockwise", "Rotate 90 clockwise", "Rotate image 180", "Rotate 180"
                    removeSelectionInAdvance = True
                    
                Case "Rotate image 90 counter-clockwise", "Rotate 90 counter-clockwise", "Arbitrary image rotation", "Arbitrary rotation"
                    removeSelectionInAdvance = True
                    
                Case "Flip image vertically", "Flip vertically", "Flip image horizontally", "Flip horizontally", "Tile"
                    removeSelectionInAdvance = True
                    
                Case Else
                    removeSelectionInAdvance = False
            
            End Select
            
            'If selection removal is required, process the removal before proceeding with the original process request
            If removeSelectionInAdvance Then
                Process "Remove selection", , , UNDO_SELECTION
                removeSelectionInAdvance = False
            End If
            
            'We also need to catch another strange occurrence here.  PD's "Crop" command forcibly clears the selection upon completion.
            ' This is done as a convenience, as post-crop, a selection is unlikely to be useful.  Unfortunately, this behavior wreaks
            ' havoc on PD's Undo/Redo engine, because the Undo/Redo engine only saves image state *after* an action has completed.
            ' So the image's state post-Crop is saved nicely, but pre-Crop it may not be, because the selection is removed out-of-process.
            ' We also can't remove the selection prior to cropping, because we obviously need its data to process the crop!
            
            'Thus the need for this workaround.  Prior to applying a crop, we ask the Undo/Redo engine to forcibly change its previous
            ' Undo record to an UNDO_EVERYTHING entry.  This will back up both the image and selection state prior to the crop, without
            ' doing anything problematic like adding dummy entries to the Undo/Redo chain.
            '
            '(Note that the initial "Crop" process (e.g. the one generated by the main menu) requests showDialog as TRUE, even though
            ' no dialog is shown.  It does this to fire off some diagnostic code that determines whether a non-destructive crop can
            ' be applied; anyway, because of this, we only need to forcibly modify the previous Undo entry if showDialog is FALSE.)
            If (processID = "Crop") And (Not showDialog) Then pdImages(g_CurrentImage).undoManager.forceLastUndoDataToIncludeEverything
            
        End If
        
    End If
    
    'If the macro recorder is running and this action is marked as recordable, store it in our running stack of processor calls
    If (MacroStatus = MacroSTART) And recordAction Then
    
        'Increase the process count
        ProcessCount = ProcessCount + 1
        
        'Copy the current process's information into the tracking array
        ReDim Preserve Processes(0 To ProcessCount) As ProcessCall
        
        With Processes(ProcessCount)
            .Id = processID
            .Dialog = showDialog
            .Parameters = processParameters
            .MakeUndo = createUndo
            .Tool = relevantTool
            .Recorded = recordAction
        End With
        
    End If
    
    'If a dialog is being displayed, forcibly disable Undo creation
    If showDialog Then createUndo = UNDO_NOTHING
    
    'If this action requires us to create an Undo entry, do so now.  (We can also use this identifier to initiate a few
    ' other, related actions.)
    If createUndo <> UNDO_NOTHING Then
        
        'Temporarily disable drag-and-drop operations for the main form while external actions are processing
        g_AllowDragAndDrop = False
        FormMain.OLEDropMode = 0
        
        'Save this action's information in the LastProcess variable (to be used if the user clicks on Edit -> Redo Last Action)
        FormMain.MnuEdit(2).Enabled = True
        With LastProcess
            .Id = processID
            .Dialog = showDialog
            .Parameters = processParameters
            .MakeUndo = createUndo
            .Tool = relevantTool
            .Recorded = recordAction
        End With
        
        'If the user wants us to time how long this action takes, mark the current time now
        If g_DisplayTimingReports Then m_ProcessingTime = Timer
        
        'Finally, perform a check for any on-canvas modifications that have not yet had their Undo data saved.
        
        'First, check for on-canvas modifications to the selection (e.g. feathering slider changes, etc)
        If Not pdImages(g_CurrentImage) Is Nothing Then
        
            If pdImages(g_CurrentImage).selectionActive And (createUndo <> UNDO_SELECTION) And (createUndo <> UNDO_EVERYTHING) Then
            
                'Ask the Undo engine to return the last selection param string it has on file
                Dim lastSelParamString As String
                lastSelParamString = pdImages(g_CurrentImage).undoManager.getLastParamString(UNDO_SELECTION)
                
                'If such a param string exists, compare it against the current selection param string
                If Len(lastSelParamString) <> 0 Then
                
                    'If the last selection Undo param string does not match the current selection param string, the user has
                    ' modified the selection in some way since the last Undo was created.  Create a new entry now.
                    If StrComp(lastSelParamString, pdImages(g_CurrentImage).mainSelection.getSelectionParamString, vbTextCompare) <> 0 Then
                        pdImages(g_CurrentImage).undoManager.createUndoData "Modify selection", pdImages(g_CurrentImage).mainSelection.getSelectionParamString, UNDO_SELECTION, , -1
                    End If
                
                End If
            
            End If
            
        End If
        
        'In the future, additional on-canvas modifications can be checked here.
        
    End If
        
    
    
    '******************************************************************************************************************
    '
    'BEGIN PROCESS SORTING
    '
    'The bulk of this routine starts here.  From this point on, the processID string is compared against a hard-coded
    ' list of every possible PhotoDemon action, filter, or other operation.  Depending on the processID, additional
    ' actions will be performed.
    '
    'Note that prior to the 6.0 release, this function used numeric identifiers instead of strings.  This has since
    ' been abandoned in favor of a string-based approach, and at present there are no plans to restore the old
    ' numeric behavior.  Strings simplify the code, they make it much easier to add new functions, and they will
    ' eventually allow for a "filter browser" that allows the user to preview any effect from a single dialog.
    ' Numeric IDs were much harder to manage in that context, and over time their numbering grew so arbitrary that
    ' it made maintenance very difficult.
    '
    'For ease of reference, the various processIDs are divided into categories of similar functions.  These categories
    ' match the organization of PhotoDemon's menus.  Please note that such organization (in this function, anyway) is
    ' simply to improve readability; there is no functional implication.
    '
    '******************************************************************************************************************
    
    Select Case processID
    
        'FILE MENU FUNCTIONS
        ' This includes actions like opening or saving images.  These actions are never recorded.
        
        Case "New image"
            If showDialog Then
                ShowPDDialog vbModal, FormNewImage
            Else
                File_Menu.CreateNewImage cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetLong(5)
            End If
                    
        Case "Open"
            File_Menu.MenuOpen
            
        Case "Close"
            File_Menu.MenuClose
            
        Case "Close all"
            File_Menu.MenuCloseAll
        
        Case "Save"
            File_Menu.MenuSave g_CurrentImage
            
        Case "Save as"
            File_Menu.MenuSaveAs g_CurrentImage
            
        Case "Save copy"
            File_Menu.MenuSaveLosslessCopy g_CurrentImage
            
        Case "Revert"
            If FormMain.MnuFile(9).Enabled Then
                pdImages(g_CurrentImage).undoManager.revertToLastSavedState
                
                'Also, redraw the current child form icon and the image tab-bar
                createCustomFormIcon pdImages(g_CurrentImage)
                toolbar_ImageTabs.notifyUpdatedImage g_CurrentImage
            End If
            
        Case "Batch wizard"
            If showDialog Then
                
                'Because the Batch Wizard window provides a custom drag/drop implementation, we disable regular drag/drop while it's active
                g_AllowDragAndDrop = False
                ShowPDDialog vbModal, FormBatchWizard
                g_AllowDragAndDrop = True
                
            End If
            
        Case "Print"
            If showDialog Then
                
                'As a temporary workaround, Vista+ users are routed through the default Windows photo printing
                ' dialog.  XP users get the old PD print dialog.
                If g_IsVistaOrLater Then
                    Printing.printViaWindowsPhotoPrinter
                Else
                    If Not FormPrint.Visible Then ShowPDDialog vbModal, FormPrint
                End If
                
                'In the future, the print dialog will be replaced with this new version.  However, there are
                ' bigger priorities for 6.2, so I'm putting this on hold for now...
                'If Not FormPrintNew.Visible Then showPDDialog vbModal, FormPrintNew
                
            End If
            
        Case "Exit program"
            Unload FormMain
            
            'If the user does not cancel the exit, we must forcibly exit this sub (otherwise the program will not exit)
            If g_ProgramShuttingDown Then Exit Sub
        
        Case "Select scanner or camera"
            Twain32SelectScanner
            
        Case "Scan image"
            Twain32Scan
            
        Case "Screen capture"
            If showDialog Then
                ShowPDDialog vbModal, FormScreenCapture
            Else
                CaptureScreen cParams.GetBool(1), cParams.GetBool(2), cParams.GetLong(3), cParams.GetBool(4), cParams.GetString(5)
            End If
            
        Case "Internet import"
            If showDialog Then
                ShowPDDialog vbModal, FormInternetImport
            End If
            
        
        
        'EDIT MENU FUNCTIONS
        ' This includes things like copying or pasting an image.  These actions are never recorded.
        
        Case "Undo"
            If FormMain.MnuEdit(0).Enabled Then
                pdImages(g_CurrentImage).undoManager.RestoreUndoData
                
                'Also, redraw the current child form icon and the image tab-bar
                createCustomFormIcon pdImages(g_CurrentImage)
                toolbar_ImageTabs.notifyUpdatedImage g_CurrentImage
            End If
            
        Case "Redo"
            If FormMain.MnuEdit(1).Enabled Then
                pdImages(g_CurrentImage).undoManager.RestoreRedoData
                
                'Also, redraw the current child form icon and the image tab-bar
                createCustomFormIcon pdImages(g_CurrentImage)
                toolbar_ImageTabs.notifyUpdatedImage g_CurrentImage
            End If
            
        Case "Undo history"
            If showDialog Then
                ShowPDDialog vbModal, FormUndoHistory
            Else
                pdImages(g_CurrentImage).undoManager.moveToSpecificUndoPoint cParams.GetLong(1)
            End If
        
        Case "Cut"
            g_Clipboard.ClipboardCut True
        
        Case "Cut from layer"
            g_Clipboard.ClipboardCut False
            
        Case "Copy"
            g_Clipboard.ClipboardCopy True
            
        Case "Copy from layer"
            g_Clipboard.ClipboardCopy False
            
        Case "Paste as new image"
            g_Clipboard.ClipboardPaste False
        
        Case "Paste as new layer"
        
            'Perform a quick check; if no images have been loaded, secretly reroute the Ctrl+Shift+V shortcut as "Paste as new image"
            If g_OpenImageCount > 0 Then
                g_Clipboard.ClipboardPaste True
            Else
                g_Clipboard.ClipboardPaste False
            End If
                    
        Case "Empty clipboard"
            g_Clipboard.ClipboardEmpty
        
        
        
        'TOOL (AND TOOL MENU) FUNCTIONS
        ' Macro recording actions.  Note that macro actions themselves are never recorded.
        Case "Start macro recording"
            StartMacro
        
        Case "Stop macro recording"
            StopMacro
            
        Case "Play macro"
            PlayMacro
        
        
        'Quick-fix tools
        Case "Make quick-fixes permanent"
            Tool_Support.makeQuickFixesPermanent
        
        
        'IMAGE MENU FUNCTIONS
        ' This includes all actions that can only operate on a full image (never selections).  These actions are recorded.
        
        'Duplicate image
        Case "Duplicate image"
            
            'It may seem odd, but the Duplicate function can be found in the "Loading" module; I do this because
            ' we effectively LOAD a copy of the original image, so all loading operations (create a form, catalog
            ' metadata, initialize properties) have to be repeated.
            DuplicateCurrentImage
            
        'Resize operations; note that prior to 6.4, "Resize" was used in place of "Resize image".  To preserve functionality of old macros,
        ' we add the old "Resize" operator here as well.
        Case "Resize image", "Resize"
            If showDialog Then
                showResizeDialog PD_AT_WHOLEIMAGE
            Else
                FormResize.ResizeImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetLong(5), cParams.GetLong(6, MU_PIXELS), cParams.GetLong(7, 96), PD_AT_WHOLEIMAGE
            End If
            
        Case "Content-aware image resize"
            If showDialog Then
                showContentAwareResizeDialog PD_AT_WHOLEIMAGE
            Else
                FormResizeContentAware.SmartResizeImage cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3, MU_PIXELS), cParams.GetLong(4, 96), PD_AT_WHOLEIMAGE
            End If
        
        'Canvas size operations
        Case "Canvas size"
            If showDialog Then
                ShowPDDialog vbModal, FormCanvasSize
            Else
                FormCanvasSize.ResizeCanvas cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetLong(5, MU_PIXELS), cParams.GetLong(6, 96)
            End If
            
        Case "Fit canvas to layer"
            Filters_Transform.MenuFitCanvasToLayer cParams.GetLong(1)
        
        Case "Fit canvas to all layers"
            Filters_Transform.MenuFitCanvasToAllLayers
        
        'Crop operations
        Case "Crop"
            
            'The main form will submit "Crop" requests with showDialog set to TRUE.  This tells us to ask the crop handler if a
            ' non-destructive crop is possible.  Depending on what it finds, it will submit a second "Crop" requests with showDialog
            ' set to FALSE.  This tells us to actually apply the crop instead of just running diagnostics.
            If showDialog Then
                Filters_Transform.seeIfCropCanBeAppliedNonDestructively
            Else
                MenuCropToSelection cParams.GetBool(1, False)
            End If
            
        'Case "Autocrop"
        '    AutocropImage
        
        Case "Trim empty borders"
            Filters_Transform.TrimImage
            
        'Rotate operations
        Case "Straighten image"
            If showDialog Then
                showStraightenDialog PD_AT_WHOLEIMAGE
            Else
                FormStraighten.StraightenImage cParams.GetDouble(1), cParams.GetLong(2)
            End If
        
        Case "Rotate image 90 clockwise", "Rotate 90 clockwise"
            MenuRotate90Clockwise
            
        Case "Rotate image 180", "Rotate 180"
            MenuRotate180
            
        Case "Rotate image 90 counter-clockwise", "Rotate 90 counter-clockwise"
            MenuRotate270Clockwise
            
        Case "Arbitrary image rotation", "Arbitrary rotation"
            If showDialog Then
                showRotateDialog PD_AT_WHOLEIMAGE
            Else
                FormRotate.RotateArbitrary cParams.GetLong(1), cParams.GetDouble(2), cParams.GetLong(3)
            End If
            
        'Other coordinate transforms
        Case "Flip image vertically", "Flip vertically"
            MenuFlip
            
        Case "Flip image horizontally", "Flip horizontally"
            MenuMirror
        
        'NOTE: isometric conversion was removed in v6.4
        Case "Isometric conversion"
            'FilterIsometric
            
        Case "Tile"
            If showDialog Then
                ShowPDDialog vbModal, FormTile
            Else
                FormTile.GenerateTile cParams.GetByte(1), cParams.GetLong(2), cParams.GetLong(3)
            End If
        
        
        'Other miscellaneous image-only items
        Case "Count image colors"
            MenuCountColors
            
        Case "Reduce colors"
            If showDialog Then
                ShowPDDialog vbModal, FormReduceColors
            Else
                FormReduceColors.ReduceImageColors_Auto cParams.GetLong(2)
            End If
        
        
        
        'LAYER FUNCTIONS
        ' Any action triggered from the Layer menu, or the Layer toolbox - creating layers, moving them, etc
        
        'Add layers to an image
        Case "Add blank layer"
            Layer_Handler.addBlankLayer cParams.GetLong(1)
        
        Case "Add new layer"
            If showDialog Then
                ShowPDDialog vbModal, FormNewLayer
            Else
                Layer_Handler.addNewLayer cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetLong(5), cParams.GetBool(6), cParams.GetString(7)
            End If
        
        'TODO: sort out new text layer vs new typography layer behavior
        Case "New text layer", "New typography layer"
            'During normal usage, "New text layer" is a dummy entry used by the on-canvas text tool.  It is called *after* a new layer
            ' has already been created, and the sole purpose of the function is to add the newly created text layer to the Undo/Redo chain.
            '
            'During macro playback, "New text layer" becomes more important, as we do actually need to create the layer!
            If (MacroStatus = MacroPLAYBACK) Or (MacroStatus = MacroBATCH) Then
                
                'Start by creating a new layer
                If StrComp(processID, "New text layer", vbTextCompare) Then
                    Layer_Handler.addNewLayer pdImages(g_CurrentImage).getActiveLayerIndex, PDL_TEXT, 0, 0, 0, True, "", 0, 0, True
                Else
                    Layer_Handler.addNewLayer pdImages(g_CurrentImage).getActiveLayerIndex, PDL_TYPOGRAPHY, 0, 0, 0, True, "", 0, 0, True
                End If
                
                'Five parameters are passed during text layer creation:
                ' 1, 2) X, Y offset
                With pdImages(g_CurrentImage).getActiveLayer
                    .setLayerOffsetX cParams.GetSingle(1)
                    .setLayerOffsetY cParams.GetSingle(2)
                
                ' 3, 4) Width, Height
                    .setLayerWidth cParams.GetSingle(3)
                    .setLayerHeight cParams.GetSingle(4)
                    
                ' 5) Vector XML data
                    .CreateVectorDataFromXML cParams.GetString(5)
                
                End With
                
            End If
        
        Case "New layer from file"
            Layer_Handler.LoadImageAsNewLayer showDialog, processParameters
        
        Case "Duplicate layer"
            Layer_Handler.duplicateLayerByIndex cParams.GetLong(1)
            
        'Remove layers from an image
        Case "Delete layer"
            Layer_Handler.deleteLayer cParams.GetLong(1)
        
        Case "Delete hidden layers"
            Layer_Handler.deleteHiddenLayers
            
        'Merge a layer up or down
        Case "Merge layer down"
            Layer_Handler.mergeLayerAdjacent cParams.GetLong(1), True
            
        Case "Merge layer up"
            Layer_Handler.mergeLayerAdjacent cParams.GetLong(1), False
            
        'Raise a layer up or down
        Case "Raise layer"
            Layer_Handler.moveLayerAdjacent cParams.GetLong(1), True
        
        Case "Lower layer"
            Layer_Handler.moveLayerAdjacent cParams.GetLong(1), False
            
        'Raise or lower to layer to end of stack
        Case "Raise layer to top"
            Layer_Handler.moveLayerToEndOfStack cParams.GetLong(1), True
        
        Case "Lower layer to bottom"
            Layer_Handler.moveLayerToEndOfStack cParams.GetLong(1), False
        
        'Non-destructive layer size and orientation changes
        Case "Reset layer angle"
            Layer_Handler.resetLayerAngle cParams.GetLong(1)
        
        Case "Reset layer size"
            Layer_Handler.resetLayerSize cParams.GetLong(1)
            
        Case "Reset horizontal layer shear"
            Layer_Handler.resetLayerShear cParams.GetLong(1), True
        
        Case "Reset vertical layer shear"
            Layer_Handler.resetLayerShear cParams.GetLong(1), False
        
        ' (Just kidding, this action is destructive, but it sits on the non-destructive panel so I've included it here)
        Case "Make layer changes permanent"
            Layer_Handler.MakeLayerAffineTransformsPermanent cParams.GetLong(1)
            
        'Destructive layer orientation changes
        Case "Straighten layer"
            If showDialog Then
                showStraightenDialog PD_AT_SINGLELAYER
            Else
                FormStraighten.StraightenImage cParams.GetDouble(1), cParams.GetLong(2)
            End If
            
        Case "Rotate layer 90 clockwise"
            MenuRotate90Clockwise pdImages(g_CurrentImage).getActiveLayerIndex
            
        Case "Rotate layer 180"
            MenuRotate180 pdImages(g_CurrentImage).getActiveLayerIndex
            
        Case "Rotate layer 90 counter-clockwise"
            MenuRotate270Clockwise pdImages(g_CurrentImage).getActiveLayerIndex
            
        Case "Arbitrary layer rotation"
            If showDialog Then
                showRotateDialog PD_AT_SINGLELAYER
            Else
                FormRotate.RotateArbitrary cParams.GetLong(1), cParams.GetDouble(2), cParams.GetLong(3)
            End If
            
        Case "Flip layer horizontally"
            MenuMirror pdImages(g_CurrentImage).getActiveLayerIndex
        
        Case "Flip layer vertically"
            MenuFlip pdImages(g_CurrentImage).getActiveLayerIndex
                
        'Destructive layer size changes
        Case "Resize layer"
            If showDialog Then
                showResizeDialog PD_AT_SINGLELAYER
            Else
                FormResize.ResizeImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetLong(5), cParams.GetLong(6, MU_PIXELS), cParams.GetLong(7, 96), PD_AT_SINGLELAYER
            End If
        
        Case "Content-aware layer resize"
            If showDialog Then
                showContentAwareResizeDialog PD_AT_SINGLELAYER
            Else
                FormResizeContentAware.SmartResizeImage cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3, MU_PIXELS), cParams.GetLong(4, 96), PD_AT_SINGLELAYER
            End If
            
        Case "Crop layer to selection"
            Layer_Handler.CropLayerToSelection pdImages(g_CurrentImage).getActiveLayerIndex
        
        'Change layer alpha
        Case "Add alpha channel"
            If showDialog Then
                ShowPDDialog vbModal, FormTransparency_Basic
            Else
                FormTransparency_Basic.simpleConvert32bpp cParams.GetLong(1)
            End If
            
        Case "Color to alpha"
            If showDialog Then
                ShowPDDialog vbModal, FormTransparency_FromColor
            Else
                FormTransparency_FromColor.colorToAlpha cParams.GetLong(1), cParams.GetDouble(2), cParams.GetDouble(3)
            End If
            
        Case "Remove alpha channel"
            If showDialog Then
                ShowPDDialog vbModal, FormConvert24bpp
            Else
                ConvertImageColorDepth 24, cParams.GetLong(1)
            End If
        
        'Rasterizing
        Case "Rasterize layer"
            Layer_Handler.RasterizeLayer pdImages(g_CurrentImage).getActiveLayerIndex
        
        Case "Rasterize all layers"
            Layer_Handler.RasterizeLayer -1
        
        'Flatten image
        Case "Flatten image"
            Layer_Handler.flattenImage
            
        'Merge visible layers
        Case "Merge visible layers"
            Layer_Handler.mergeVisibleLayers
            
        'On-canvas layer modifications (moving, non-destructive resizing, etc)
        Case "Resize layer (on-canvas)"
            Layer_Handler.resizeLayerNonDestructive pdImages(g_CurrentImage).getActiveLayerIndex, cParams.getParamString
        
        Case "Rotate layer (on-canvas)"
            Layer_Handler.rotateLayerNonDestructive pdImages(g_CurrentImage).getActiveLayerIndex, cParams.getParamString
        
        Case "Move layer"
            Layer_Handler.moveLayerOnCanvas pdImages(g_CurrentImage).getActiveLayerIndex, cParams.getParamString
            
        '"Rearrange layers" is a dummy entry.  It does not actually modify the image; its sole purpose is to create an Undo/Redo entry
        ' after the user has performed a drag/drop rearrangement of the layer stack.
        Case "Rearrange layers"
            
        
        'SELECTION FUNCTIONS
        ' Any action that operates on selections - creating them, moving them, erasing them, etc
        
        
        'Create/remove selections
        Case "Create selection"
            Selection_Handler.CreateNewSelection cParams.getParamString
        
        Case "Remove selection"
            Selection_Handler.RemoveCurrentSelection
                    
        
        'Modify the existing selection in some way
        Case "Invert selection"
            Selection_Handler.invertCurrentSelection
            
        Case "Grow selection"
            If showDialog Then
                Selection_Handler.growCurrentSelection True
            Else
                Selection_Handler.growCurrentSelection False, cParams.GetDouble(1)
            End If
            
        Case "Shrink selection"
            If showDialog Then
                Selection_Handler.shrinkCurrentSelection True
            Else
                Selection_Handler.shrinkCurrentSelection False, cParams.GetDouble(1)
            End If
        
        Case "Feather selection"
            If showDialog Then
                Selection_Handler.featherCurrentSelection True
            Else
                Selection_Handler.featherCurrentSelection False, cParams.GetDouble(1)
            End If
        
        Case "Sharpen selection"
            If showDialog Then
                Selection_Handler.sharpenCurrentSelection True
            Else
                Selection_Handler.sharpenCurrentSelection False, cParams.GetDouble(1)
            End If
            
        Case "Border selection"
            If showDialog Then
                Selection_Handler.borderCurrentSelection True
            Else
                Selection_Handler.borderCurrentSelection False, cParams.GetDouble(1)
            End If
        
        'Erase selected area (from layer)
        Case "Erase selected area"
            Selection_Handler.eraseSelectedArea cParams.GetLong(1)
        
        'Load/save selection from/to file
        Case "Load selection"
            If showDialog Then
                Selection_Handler.LoadSelectionFromFile True
            Else
                Selection_Handler.LoadSelectionFromFile False, cParams.getParamString
            End If
            
        Case "Save selection"
            Selection_Handler.SaveSelectionToFile
            
        'Export selected area as image (defaults to PNG, but user can select the actual format)
        Case "Export selected area as image"
            Selection_Handler.ExportSelectedAreaAsImage
        
        'Export selection mask as image (defaults to PNG, but user can select the actual format)
        Case "Export selection mask as image"
            Selection_Handler.ExportSelectionMaskAsImage
        
        ' This is a dummy entry; it only exists so that Undo/Redo data is correctly generated when a selection is moved
        Case "Move selection"
            Selection_Handler.CreateNewSelection cParams.getParamString
            
        ' This is a dummy entry; it only exists so that Undo/Redo data is correctly generated when a selection is resized
        Case "Resize selection"
            Selection_Handler.CreateNewSelection cParams.getParamString
        
        Case "Select all"
            Selection_Handler.SelectWholeImage
        
        
        
        'ADJUSTMENT FUNCTIONS
        ' Any action that is used to fix or correct problems with an image, including basic color space transformations (e.g. grayscale/sepia)
        
        'Auto correct functions
        Case "Auto correct color"
            FormWhiteBalance.AutoWhiteBalance
            Unload FormWhiteBalance
        
        Case "Auto correct contrast"
            Filters_Miscellaneous.AutoContrastCorrect
        
        Case "Auto correct lighting"
            FormLevels.MapImageLevels FormLevels.getIdealLevelParamString(pdImages(g_CurrentImage).getActiveDIB)
            Unload FormLevels
            
        Case "Auto correct shadows and highlights"
            Filters_Color_Effects.fxAutoCorrectShadowsAndHighlights
        
        'Auto enhance functions
        Case "Auto enhance color"
            Filters_Color_Effects.fxAutoEnhanceColors
        
        Case "Auto enhance contrast"
            Filters_Color_Effects.fxAutoEnhanceContrast
        
        Case "Auto enhance lighting"
            Filters_Color_Effects.fxAutoEnhanceLighting
            
        Case "Auto enhance shadows and highlights"
            Filters_Color_Effects.fxAutoEnhanceShadowsAndHighlights
        
        'Luminance adjustment functions
        Case "Brightness and contrast"
            If showDialog Then
                ShowPDDialog vbModal, FormBrightnessContrast
            Else
                FormBrightnessContrast.BrightnessContrast cParams.GetLong(1), cParams.GetDouble(2), cParams.GetBool(3)
            End If
        
        Case "Curves"
            If showDialog Then
                ShowPDDialog vbModal, FormCurves
            Else
                FormCurves.ApplyCurveToImage cParams.getParamString
            End If
            
        Case "Gamma"
            If showDialog Then
                ShowPDDialog vbModal, FormGamma
            Else
                FormGamma.GammaCorrect cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3)
            End If
        
        Case "Levels"
            If showDialog Then
                ShowPDDialog vbModal, FormLevels
            Else
                FormLevels.MapImageLevels cParams.getParamString
            End If
            
        Case "Shadow and highlight"
            If showDialog Then
                ShowPDDialog vbModal, FormShadowHighlight
            Else
                FormShadowHighlight.ApplyShadowHighlight cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetDouble(5), cParams.GetLong(6), cParams.GetDouble(7)
            End If
            
        Case "White balance"
            If showDialog Then
                ShowPDDialog vbModal, FormWhiteBalance
            Else
                FormWhiteBalance.AutoWhiteBalance cParams.GetDouble(1)
            End If
        
        'Color adjustments
        Case "Color balance"
            If showDialog Then
                ShowPDDialog vbModal, FormColorBalance
            Else
                FormColorBalance.ApplyColorBalance cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetBool(5)
            End If
            
        Case "Hue and saturation"
            If showDialog Then
                ShowPDDialog vbModal, FormHSL
            Else
                FormHSL.AdjustImageHSL cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3)
            End If
            
        Case "Replace color"
            If showDialog Then
                ShowPDDialog vbModal, FormReplaceColor
            Else
                FormReplaceColor.ReplaceSelectedColor cParams.GetLong(1), cParams.GetLong(2), cParams.GetDouble(3), cParams.GetDouble(4)
            End If
            
        Case "Temperature"
            If showDialog Then
                ShowPDDialog vbModal, FormColorTemp
            Else
                FormColorTemp.ApplyTemperatureToImage cParams.GetLong(1), cParams.GetBool(2), cParams.GetDouble(3)
            End If
            
        Case "Tint"
            If showDialog Then
                ShowPDDialog vbModal, FormTint
            Else
                FormTint.adjustTint cParams.GetLong(1)
            End If
            
        Case "Vibrance"
            If showDialog Then
                ShowPDDialog vbModal, FormVibrance
            Else
                FormVibrance.Vibrance cParams.GetDouble(1)
            End If
        
        'Miscellaneous adjustments
        Case "Colorize"
            If showDialog Then
                ShowPDDialog vbModal, FormColorize
            Else
                FormColorize.ColorizeImage cParams.GetDouble(1), cParams.GetBool(2)
            End If
        
        'Grayscale conversions
        Case "Black and white"
            If showDialog Then
                ShowPDDialog vbModal, FormGrayscale
            Else
                FormGrayscale.masterGrayscaleFunction cParams.GetLong(1), cParams.GetString(2), cParams.GetLong(3, 256), cParams.GetLong(4, 0)
            End If
        
        'Invert operations
        Case "Invert RGB"
            MenuInvert
            
        Case "Compound invert"
            MenuCompoundInvert cParams.GetLong(1)
            
        Case "Film negative"
            MenuNegative
            
        Case "Invert hue"
            MenuInvertHue
        
        'Monochrome conversion
        ' (Note: all monochrome conversion operations are condensed into a single function.  (Past versions spread them across multiple functions.))
        Case "Color to monochrome"
            If showDialog Then
                ShowPDDialog vbModal, FormMonochrome
            Else
                FormMonochrome.masterBlackWhiteConversion cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
            
        Case "Monochrome to grayscale"
            If showDialog Then
                ShowPDDialog vbModal, FormMonoToColor
            Else
                FormMonoToColor.ConvertMonoToColor cParams.GetLong(1)
            End If
            
        Case "Sepia"
            MenuSepia
            
        'Channel operations
        Case "Channel mixer"
            If showDialog Then
                ShowPDDialog vbModal, FormChannelMixer
            Else
                FormChannelMixer.ApplyChannelMixer cParams.getParamString
            End If
            
        Case "Rechannel"
            If showDialog Then
                ShowPDDialog vbModal, FormRechannel
            Else
                FormRechannel.RechannelImage cXMLParams.getParamString
            End If
            
        Case "Shift colors (left)"
            MenuCShift 1
            
        Case "Shift colors (right)"
            MenuCShift 0
                    
        Case "Maximum channel"
            FilterMaxMinChannel True
        
        Case "Minimum channel"
            FilterMaxMinChannel False
            
        'Histogram functions
        Case "Display histogram"
            ShowPDDialog vbModal, FormHistogram
        
        Case "Stretch histogram"
            FormHistogram.StretchHistogram
            
        Case "Equalize"
            If showDialog Then
                ShowPDDialog vbModal, FormEqualize
            Else
                FormEqualize.EqualizeHistogram cParams.GetBool(1), cParams.GetBool(2), cParams.GetBool(3), cParams.GetBool(4)
            End If
        
        'Photography sub-menu functions
        Case "Exposure"
            If showDialog Then
                ShowPDDialog vbModal, FormExposure
            Else
                FormExposure.Exposure cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3)
            End If
        
        Case "HDR"
            If showDialog Then
                ShowPDDialog vbModal, FormHDR
            Else
                FormHDR.ApplyImitationHDR cParams.GetDouble(1), cParams.GetDouble(2)
            End If
            
        Case "Photo filter"
            If showDialog Then
                ShowPDDialog vbModal, FormPhotoFilters
            Else
                FormPhotoFilters.ApplyPhotoFilter cParams.GetLong(1), cParams.GetDouble(2), cParams.GetBool(3)
            End If
            
        Case "Split toning"
            If showDialog Then
                ShowPDDialog vbModal, FormSplitTone
            Else
                FormSplitTone.SplitTone cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4)
            End If
        
        'EFFECT FUNCTIONS
        'Sometimes fun, sometimes practical, no real unifying factor to these.
        
        
        'Artistic
        Case "Colored pencil"
            If showDialog Then
                ShowPDDialog vbModal, FormPencil
            Else
                FormPencil.fxColoredPencil cParams.GetLong(1), cParams.GetDouble(2), cParams.GetLong(3)
            End If
            
        Case "Comic book"
            If showDialog Then
                ShowPDDialog vbModal, FormComicBook
            Else
                FormComicBook.fxComicBook cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3, 0)
            End If
            
        Case "Figured glass"
            If showDialog Then
                ShowPDDialog vbModal, FormFiguredGlass
            Else
                FormFiguredGlass.FiguredGlassFX cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
        
        Case "Film noir"
            If showDialog Then
                ShowPDDialog vbModal, FormFilmNoir
            Else
                FormFilmNoir.fxFilmNoir cXMLParams.getParamString
            End If
            
        Case "Glass tiles"
            If showDialog Then
                ShowPDDialog vbModal, FormGlassTiles
            Else
                FormGlassTiles.GlassTiles cParams.GetLong(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetLong(5)
            End If
        
        Case "Kaleidoscope"
            If showDialog Then
                ShowPDDialog vbModal, FormKaleidoscope
            Else
                FormKaleidoscope.KaleidoscopeImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetBool(5), cParams.GetDouble(6), cParams.GetDouble(7)
            End If
            
        Case "Modern art"
            If showDialog Then
                ShowPDDialog vbModal, FormModernArt
            Else
                FormModernArt.ApplyModernArt cXMLParams.getParamString
            End If
            
        Case "Oil painting"
            If showDialog Then
                ShowPDDialog vbModal, FormOilPainting
            Else
                FormOilPainting.ApplyOilPaintingEffect cXMLParams.getParamString
            End If
            
        Case "Posterize"
            If showDialog Then
                ShowPDDialog vbModal, FormPosterize
            Else
                FormPosterize.ReduceImageColors_BitRGB cParams.GetByte(1), cParams.GetByte(2), cParams.GetByte(3), cParams.GetBool(4)
            End If
            
        Case "Posterize (dithered)"
            FormPosterize.ReduceImageColors_BitRGB_ErrorDif cParams.GetByte(1), cParams.GetByte(2), cParams.GetByte(3), cParams.GetBool(4)
                    
        Case "Relief"
            If showDialog Then
                ShowPDDialog vbModal, FormRelief
            Else
                FormRelief.ApplyReliefEffect cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3)
            End If
            
        Case "Stained glass"
            If showDialog Then
                ShowPDDialog vbModal, FormStainedGlass
            Else
                FormStainedGlass.fxStainedGlass cParams.GetLong(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetDouble(5), cParams.GetLong(6)
            End If
            
        'Blur
        
        'Standard blur filters
        Case "Box blur"
            If showDialog Then
                ShowPDDialog vbModal, FormBoxBlur
            Else
                FormBoxBlur.BoxBlurFilter cParams.GetLong(1), cParams.GetLong(2)
            End If
            
        Case "Gaussian blur"
            If showDialog Then
                ShowPDDialog vbModal, FormGaussianBlur
            Else
                FormGaussianBlur.GaussianBlurFilter cParams.GetDouble(1), cParams.GetLong(2)
            End If
            
        Case "Surface blur"
            If showDialog Then
                ShowPDDialog vbModal, FormSurfaceBlur
            Else
                FormSurfaceBlur.SurfaceBlurFilter cParams.GetDouble(1), cParams.GetByte(2), cParams.GetBool(3), cParams.GetLong(4, 1)
            End If
            
        'Motion (directional) blurs
        Case "Motion blur"
            If showDialog Then
                ShowPDDialog vbModal, FormMotionBlur
            Else
                FormMotionBlur.MotionBlurFilter cParams.GetDouble(1), cParams.GetLong(2), cParams.GetBool(3), cParams.GetLong(4)
            End If
            
        Case "Radial blur"
            If showDialog Then
                ShowPDDialog vbModal, FormRadialBlur
            Else
                FormRadialBlur.RadialBlurFilter cParams.GetDouble(1), cParams.GetBool(2), cParams.GetBool(3)
            End If
        
        Case "Zoom blur"
            If showDialog Then
                ShowPDDialog vbModal, FormZoomBlur
            Else
                FormZoomBlur.ZoomBlurWrapper cParams.GetBool(1), cParams.GetLong(2)
            End If
            
        'Miscellaneous blurs
        Case "Chroma blur"
            If showDialog Then
                ShowPDDialog vbModal, FormChromaBlur
            Else
                FormChromaBlur.ChromaBlurFilter cParams.GetDouble(1), cParams.GetLong(2)
            End If
            
        Case "Kuwahara filter"
            If showDialog Then
                ShowPDDialog vbModal, FormKuwahara
            Else
                FormKuwahara.Kuwahara cParams.GetLong(1)
            End If
        
        Case "Grid blur"
            FilterGridBlur
            
        
        'Distort filters
        
        Case "Apply lens distortion"
            If showDialog Then
                ShowPDDialog vbModal, FormLens
            Else
                FormLens.ApplyLensDistortion cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetDouble(4), cParams.GetDouble(5)
            End If
            
        Case "Correct lens distortion"
            If showDialog Then
                ShowPDDialog vbModal, FormLensCorrect
            Else
                FormLensCorrect.ApplyLensCorrection cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetLong(5)
            End If
        
        Case "Donut"
            If showDialog Then
                ShowPDDialog vbModal, FormDonut
            Else
                FormDonut.ApplyDonutDistortion cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetLong(5), cParams.GetLong(6), cParams.GetDouble(7), cParams.GetDouble(8)
            End If
        
        Case "Miscellaneous distort"
            If showDialog Then
                ShowPDDialog vbModal, FormMiscDistorts
            Else
                FormMiscDistorts.ApplyMiscDistort cParams.GetString(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
            
        Case "Pan and zoom"
            If showDialog Then
                ShowPDDialog vbModal, FormPanAndZoom
            Else
                FormPanAndZoom.PanAndZoomFilter cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetLong(5)
            End If
        
        Case "Perspective"
            If showDialog Then
                ShowPDDialog vbModal, FormPerspective
            Else
                FormPerspective.PerspectiveImage cParams.getParamString
            End If
            
        Case "Pinch and whirl"
            If showDialog Then
                ShowPDDialog vbModal, FormPinch
            Else
                FormPinch.PinchImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetLong(5), cParams.GetDouble(6), cParams.GetDouble(7)
            End If
            
        Case "Poke"
            If showDialog Then
                ShowPDDialog vbModal, FormPoke
            Else
                FormPoke.ApplyPokeDistort cParams.GetDouble(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetDouble(4), cParams.GetDouble(5)
            End If
            
        Case "Polar conversion"
            If showDialog Then
                ShowPDDialog vbModal, FormPolar
            Else
                FormPolar.ConvertToPolar cParams.GetLong(1), cParams.GetBool(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetBool(5)
            End If
            
        Case "Ripple"
            If showDialog Then
                ShowPDDialog vbModal, FormRipple
            Else
                FormRipple.RippleImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetLong(5), cParams.GetLong(6), cParams.GetDouble(7), cParams.GetDouble(8)
            End If
            
        Case "Rotate"
            If showDialog Then
                ShowPDDialog vbModal, FormRotateDistort
            Else
                FormRotateDistort.RotateFilter cParams.GetDouble(1), cParams.GetLong(2), cParams.GetBool(3), cParams.GetDouble(4), cParams.GetDouble(5)
            End If
            
        Case "Shear"
            If showDialog Then
                ShowPDDialog vbModal, FormShear
            Else
                FormShear.ShearImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
            
        Case "Spherize"
            If showDialog Then
                ShowPDDialog vbModal, FormSpherize
            Else
                FormSpherize.SpherizeImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetBool(4), cParams.GetLong(5), cParams.GetLong(6)
            End If
        
        Case "Squish"
            If showDialog Then
                ShowPDDialog vbModal, FormSquish
            Else
                FormSquish.SquishImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
            
        Case "Swirl"
            If showDialog Then
                ShowPDDialog vbModal, FormSwirl
            Else
                FormSwirl.SwirlImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetDouble(5), cParams.GetDouble(6)
            End If
            
        Case "Waves"
            If showDialog Then
                ShowPDDialog vbModal, FormWaves
            Else
                FormWaves.WaveImage cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetLong(5), cParams.GetLong(6)
            End If
            
        
        'Edge filters
        Case "Emboss"
            If showDialog Then
                ShowPDDialog vbModal, FormEmbossEngrave
            Else
                FormEmbossEngrave.ApplyEmbossEffect cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4)
            End If
            
        Case "Enhance edges"
            If showDialog Then
                ShowPDDialog vbModal, FormEdgeEnhance
            Else
                FormEdgeEnhance.ApplyEdgeEnhancement cParams.GetLong(1), cParams.GetLong(2), cParams.GetDouble(3)
            End If
            
        Case "Find edges"
            If showDialog Then
                ShowPDDialog vbModal, FormFindEdges
            Else
                FormFindEdges.ApplyEdgeDetection cParams.GetLong(1), cParams.GetLong(2), cParams.GetBool(3)
            End If
            
        Case "Range filter"
            If showDialog Then
                ShowPDDialog vbModal, FormRangeFilter
            Else
                FormRangeFilter.ApplyRangeFilter cXMLParams.getParamString
            End If
            
        Case "Trace contour"
            If showDialog Then
                ShowPDDialog vbModal, FormContour
            Else
                FormContour.TraceContour cParams.GetLong(1), cParams.GetBool(2), cParams.GetBool(3)
            End If
            
        'Historically, "artistic contour" was provided as a standalone option.  It's now integrated into the base
        ' "find edges" function but its dedicated instruction has been left here for backwards compatibility reasons.
        Case "Artistic contour"
            FormFindEdges.FilterSmoothContour cParams.GetBool(1)
            
        
        'Lights and shadows
        
        Case "Black light"
            If showDialog Then
                ShowPDDialog vbModal, FormBlackLight
            Else
                FormBlackLight.fxBlackLight cParams.GetDouble(1)
            End If
        
        Case "Cross-screen"
            If showDialog Then
                ShowPDDialog vbModal, FormCrossScreen
            Else
                FormCrossScreen.CrossScreenFilter cParams.GetLong(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetDouble(5), cParams.GetLong(6)
            End If
        
        Case "Lens flare"
            If showDialog Then
                ShowPDDialog vbModal, FormLensFlare
            Else
                FormLensFlare.LensFlare cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetDouble(5), cParams.GetDouble(6), cParams.GetDouble(7)
            End If
            
        Case "Rainbow"
            If showDialog Then
                ShowPDDialog vbModal, FormRainbow
            Else
                FormRainbow.ApplyRainbowEffect cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4)
            End If
            
        Case "Sunshine"
            If showDialog Then
                ShowPDDialog vbModal, FormSunshine
            Else
                FormSunshine.SunShine cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4), cParams.GetDouble(5), cParams.GetDouble(6)
            End If
            
        Case "Dilate (maximum rank)"
            If showDialog Then
                FormMedian.showMedianDialog 100
            Else
                FormMedian.ApplyMedianFilter cXMLParams.getParamString
            End If
            
        Case "Erode (minimum rank)"
            If showDialog Then
                FormMedian.showMedianDialog 1
            Else
                FormMedian.ApplyMedianFilter cXMLParams.getParamString
            End If
        
        'Natural
        
        Case "Atmosphere"
            MenuAtmospheric
            
        Case "Fog"
            If showDialog Then
                ShowPDDialog vbModal, FormFog
            Else
                FormFog.fxFog cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
            
        Case "Freeze"
            MenuFrozen
            
        Case "Ignite"
            If showDialog Then
                ShowPDDialog vbModal, FormIgnite
            Else
                FormIgnite.fxBurn cParams.GetDouble(1), cParams.GetLong(2), cParams.GetLong(3)
            End If
            
        Case "Lava"
            MenuLava
                    
        Case "Metal"
            If showDialog Then
                ShowPDDialog vbModal, FormMetal
            Else
                FormMetal.ApplyMetalFilter cParams.GetLong(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
            
        Case "Water"
            MenuWater
            
        
        'Noise
        
        Case "Add film grain"
            If showDialog Then
                ShowPDDialog vbModal, FormFilmGrain
            Else
                FormFilmGrain.AddFilmGrain cParams.GetDouble(1), cParams.GetDouble(2)
            End If
        
        Case "Add RGB noise"
            If showDialog Then
                ShowPDDialog vbModal, FormNoise
            Else
                FormNoise.AddNoise cParams.GetLong(1), cParams.GetBool(2)
            End If
        
        Case "Bilateral smoothing"
            If showDialog Then
                ShowPDDialog vbModal, FormBilateral
            Else
            
                If cParams.GetBool(6, True) Then
                    FormBilateral.BilateralSmoothingSeparable cParams.GetLong(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetDouble(5)
                Else
                    FormBilateral.BilateralSmoothing cParams.GetLong(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetDouble(5)
                End If
                    
            End If
        
        Case "Mean shift"
            If showDialog Then
                ShowPDDialog vbModal, FormMeanShift
            Else
                FormMeanShift.ApplyMeanShiftFilter cXMLParams.getParamString
            End If
            
        Case "Median"
            If showDialog Then
                FormMedian.showMedianDialog 50
            Else
                FormMedian.ApplyMedianFilter cXMLParams.getParamString
            End If
            
        
        'Pixelate
        
        Case "Color halftone"
            If showDialog Then
                ShowPDDialog vbModal, FormColorHalftone
            Else
                FormColorHalftone.ColorHalftoneFilter cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetDouble(4), cParams.GetDouble(5)
            End If
        
        Case "Crystallize"
            If showDialog Then
                ShowPDDialog vbModal, FormCrystallize
            Else
                FormCrystallize.fxCrystallize cParams.GetLong(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
        
        Case "Fragment"
            If showDialog Then
                ShowPDDialog vbModal, FormFragment
            Else
                FormFragment.Fragment cParams.GetLong(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetLong(4), cParams.GetBool(5)
            End If
        
        Case "Mezzotint"
            If showDialog Then
                ShowPDDialog vbModal, FormMezzotint
            Else
                FormMezzotint.ApplyMezzotintEffect cParams.GetLong(1), cParams.GetLong(2), cParams.GetLong(3), cParams.GetLong(4)
            End If
        
        Case "Mosaic"
            If showDialog Then
                ShowPDDialog vbModal, FormMosaic
            Else
                FormMosaic.MosaicFilter cParams.GetLong(1), cParams.GetLong(2), cParams.GetDouble(3, 0#)
            End If
        
        
        'Sharpen
        
        Case "Sharpen"
            If showDialog Then
                ShowPDDialog vbModal, FormSharpen
            Else
                FormSharpen.ApplySharpenFilter cParams.GetDouble(1)
            End If
            
        Case "Unsharp mask"
            If showDialog Then
                ShowPDDialog vbModal, FormUnsharpMask
            Else
                FormUnsharpMask.UnsharpMask cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetLong(3), cParams.GetLong(4, 2)
            End If
            
            
        'Stylize
            
        Case "Antique"
            MenuAntique
                    
        Case "Diffuse"
            If showDialog Then
                ShowPDDialog vbModal, FormDiffuse
            Else
                FormDiffuse.DiffuseCustom cParams.GetLong(1), cParams.GetLong(2), cParams.GetBool(3)
            End If
                
        Case "Solarize"
            If showDialog Then
                ShowPDDialog vbModal, FormSolarize
            Else
                FormSolarize.SolarizeImage cParams.GetByte(1)
            End If
            
        Case "Twins"
            If showDialog Then
                ShowPDDialog vbModal, FormTwins
            Else
                FormTwins.GenerateTwins cParams.GetLong(1)
            End If
            
        Case "Vignetting"
            If showDialog Then
                ShowPDDialog vbModal, FormVignette
            Else
                FormVignette.ApplyVignette cParams.GetDouble(1), cParams.GetDouble(2), cParams.GetDouble(3), cParams.GetBool(4), cParams.GetLong(5), cParams.GetDouble(6, 0.5), cParams.GetDouble(7, 0.5)
            End If
            
        
        'Custom filters
        
        Case "Custom filter"
            If showDialog Then
                ShowPDDialog vbModal, FormCustomFilter
            Else
                ApplyConvolutionFilter cParams.getParamString
            End If
        
        
        'Experimental
        
        Case "Alien"
            MenuAlien
                    
        Case "Dream"
            MenuDream
            
        Case "Radioactive"
            MenuRadioactive
            
        Case "Synthesize"
            MenuSynthesize
        
        Case "Thermograph (heat map)"
            MenuHeatMap
        
        Case "Vibrate"
            MenuVibrate
            
            
            
        'SPECIAL OPERATIONS
        Case "Fade"
            If showDialog Then
                ShowPDDialog vbModal, FormFadeLast
            Else
                FormFadeLast.fxFadeLastAction cParams.GetDouble(1), cParams.GetLong(2)
            End If
            
        'This secret action is used internally by PD when we need some response from the processor engine - like checking for
        ' non-destructive layer changes - but the user is not actually modifying the image.
        Case "Do nothing"
        
        
        'Other specialized returns are handled here
        Case Else
        
            Select Case processID
            
                'Non-destructive layer header modifications are handled by their own specialized non-destructive processor (below).
                ' The only way this case will ever be triggered in *this function * is during macro playback.  If encountered, all
                ' "modify layer" instructions follow the same basic structure: the first parameter is a generic layer header setting
                ' ID, and the second is a layer setting value.
                Case "Modify layer"
                    
                    If (MacroStatus = MacroPLAYBACK) Or (MacroStatus = MacroBATCH) Then
                        pdImages(g_CurrentImage).getActiveLayer.setGenericLayerProperty cParams.GetLong(1), cParams.GetVariant(2)
                    End If
                
                'Text layer modifications are handled by their own specialized non-destructive processor (below).  The only way this case
                ' will ever be triggered is during macro playback.  If encountered, all "modify text layer" instructions follow the same
                ' basic structure: the first parameter is a text setting ID, and the second is a text setting value.
                Case "Modify text layer"
                    
                    If (MacroStatus = MacroPLAYBACK) Or (MacroStatus = MacroBATCH) Then
                    
                        If pdImages(g_CurrentImage).getActiveLayer.isLayerText Then
                            pdImages(g_CurrentImage).getActiveLayer.setTextLayerProperty cParams.GetLong(1), cParams.GetVariant(2)
                        End If
                    
                    End If
                    
                'Non-destructive "quick-fix" type effects follow the same logic as above.
                Case "Non-destructive effect"
                    If (MacroStatus = MacroPLAYBACK) Or (MacroStatus = MacroBATCH) Then
                        pdImages(g_CurrentImage).getActiveLayer.setLayerNonDestructiveFXState cParams.GetLong(1), cParams.GetVariant(2)
                    End If
            
                Case Else
                    'DEBUG FAILSAFE
                    ' This function should never be passed a process ID it can't parse, but if that happens, ask the user to report the unparsed ID
                    If Len(processID) <> 0 Then PDMsgBox "Unknown processor request submitted: %1" & vbCrLf & vbCrLf & "Please report this bug via the Help -> Submit Bug Report menu.", vbCritical + vbOKOnly + vbApplicationModal, "Processor Error", processID
            
            End Select
            
    End Select
    
    'If the user wants us to time this action, display the results now.  (Note - only do this for actions that will change the image
    ' in some way, as determined by the createUndo param)
    If g_DisplayTimingReports And (createUndo <> UNDO_NOTHING) Then
        
        Dim timingString As String
        
        timingString = g_Language.TranslateMessage("Time taken")
        timingString = timingString & ": " & Format$(Timer - m_ProcessingTime, "#0.####") & " "
        timingString = timingString & g_Language.TranslateMessage("seconds")
        
        Message timingString
        
    End If
    
    'Restore the mouse pointer to its default value.
    ' (NOTE: if we are in the midst of a batch conversion, leave the cursor on "busy".  The batch function will restore the cursor when done.)
    If MacroStatus <> MacroBATCH Then
        Screen.MousePointer = vbDefault
        
        '13 March 2015: I don't know why this DoEvents is here.  I have commented it out for now, but will reinstate it if I can
        ' figure out why I ever used it in the first place.
        'DoEvents
        
    End If
        
    'If the image has been modified and we are not performing a batch conversion (disabled to save speed!), redraw form and taskbar icons,
    ' as well as the image tab-bar.
    If (createUndo <> UNDO_NOTHING) And (MacroStatus <> MacroBATCH) And (Not pdImages(g_CurrentImage) Is Nothing) Then
        createCustomFormIcon pdImages(g_CurrentImage)
        toolbar_ImageTabs.notifyUpdatedImage g_CurrentImage
    End If
    
    'If the user canceled the requested action before it completed, we need to roll back the undo data we created
    If cancelCurrentAction Then
        
        'Reset any interface elements that may still be in "processing" mode.
        releaseProgressBar
        Message "Action canceled."
    
        'Reset the cancel trigger; if this is not done, the user will not be able to cancel subsequent actions.
        cancelCurrentAction = False
        
    'If the user did not cancel the action, and the action modified the image in any way, create an Undo entry now.
    Else
    
        'Generally, we assume that actions want us to create Undo data for them.  However, there are a few known exceptions:
        ' 1) If this processor request was just for displaying a dialog
        ' 2) If macro recording has been disabled for this action.  (This is typically used when an internal PD function
        '     utilizes other functions, but we only want a single Undo point created for the full set of actions.)
        ' 3) If we are in the midst of playing back a recorded macro (Undo data takes extra time to process, so we ignore it
        '     during macro playback)
        If (createUndo <> UNDO_NOTHING) And (MacroStatus <> MacroBATCH) And (Not showDialog) And recordAction And (Not pdImages(g_CurrentImage) Is Nothing) Then
        
            'An Undo file should be created.  In most cases, the parameters used are automatic (e.g. the image's active layer is
            ' assumed as the target, etc).  In some rare cases, however, we may need to supply custom parameters to the Undo engine.
            ' Check for those now.
            Dim affectedLayerID As Long
            affectedLayerID = pdImages(g_CurrentImage).getActiveLayerID
            
            'The "Edit > Fade" action is unique, because it does not necessarily affect the active layer (e.g. if the user blurs
            ' a layer, then switches to a new layer, Fade will affect the *old layer* only).  Find the relevant layer ID
            ' before calling the Undo engine.
            If processID = "Fade" Then
                Dim tmpDIB As pdDIB
                pdImages(g_CurrentImage).undoManager.fillDIBWithLastUndoCopy tmpDIB, affectedLayerID, , True
            End If
        
            'Create the Undo data
            pdImages(g_CurrentImage).undoManager.createUndoData processID, processParameters, createUndo, affectedLayerID, relevantTool
            
        End If
    
    End If
    
    'Unlock the main form
    If MacroStatus <> MacroBATCH Then FormMain.Enabled = True
        
    'If a filter or tool was just used, return focus to the active form.  This will make it "flash" to catch the user's attention.
    If (createUndo <> UNDO_NOTHING) Then
    
        If g_OpenImageCount > 0 Then ActivatePDImage g_CurrentImage, "processor call complete"
    
        'Also, re-enable drag and drop operations
        g_AllowDragAndDrop = True
        FormMain.OLEDropMode = 1
        
    End If
    
    'The interface will automatically be synched if an image is open and some undo-related action was applied,
    ' but if either of those did not occur, sync the interface now.
    SyncInterfaceToCurrentImage
    
    'Restore focus to whichever control had it previously
    If m_FocusHWnd <> 0 Then g_WindowManager.SetFocusAPI m_FocusHWnd
    
    'If an update is available, and we haven't displayed a notification yet, do so now
    If g_ShowUpdateNotification Then Software_Updater.displayUpdateNotification
        
    'Mark the processor as ready
    m_Processing = False
    
    Exit Sub

'MAIN PHOTODEMON ERROR HANDLER STARTS HERE

MainErrHandler:
    
    'Reset the mouse pointer and access to the main form
    Screen.MousePointer = vbDefault
    FormMain.Enabled = True

    'We'll use this string to hold additional error data
    Dim AddInfo As String
    
    'This variable stores the message box type
    Dim mType As VbMsgBoxStyle
    
    'Tracks the user input from the message box
    Dim msgReturn As VbMsgBoxResult
    
    'Ignore errors that aren't actually errors
    If Err.Number = 0 Then Exit Sub
    
    'Object was unloaded before it could be shown - this is intentional, so ignore the error
    If Err.Number = 364 Then Exit Sub
    
    'Out of memory error
    If Err.Number = 480 Or Err.Number = 7 Then
        AddInfo = g_Language.TranslateMessage("There is not enough memory available to continue this operation.  Please free up system memory (RAM) by shutting down unneeded programs - especially your web browser, if it is open - then try the action again.")
        Message "Out of memory.  Function canceled."
        mType = vbExclamation + vbOKOnly + vbApplicationModal
    
    'Invalid picture error
    ElseIf Err.Number = 481 Then
        AddInfo = g_Language.TranslateMessage("Unfortunately, this image file appears to be invalid.  This can happen if a file does not contain image data, or if it contains image data in an unsupported format." & vbCrLf & vbCrLf & "- If you downloaded this image from the Internet, the download may have terminated prematurely.  Please try downloading the image again." & vbCrLf & vbCrLf & "- If this image file came from a digital camera, scanner, or other image editing program, it's possible that PhotoDemon simply doesn't understand this particular file format.  Please save the image in a generic format (such as JPEG or PNG), then reload it.")
        Message "Invalid image.  Image load canceled."
        mType = vbExclamation + vbOKOnly + vbApplicationModal
    
        'Since we know about this error, there's no need to display the extended box.  Display a smaller one, then exit.
        PDMsgBox AddInfo, mType, "Invalid image file"
        
        'On an invalid picture load, there will be a blank form that needs to be dealt with.
        pdImages(g_CurrentImage).deactivateImage
        
        Exit Sub
    
    'File not found error
    ElseIf Err.Number = 53 Then
        AddInfo = g_Language.TranslateMessage("The specified file could not be located.  If it was located on removable media, please re-insert the proper floppy disk, CD, or portable drive.  If the file is not located on portable media, make sure that:" & vbCrLf & "1) the file hasn't been deleted, and..." & vbCrLf & "2) the file location provided to PhotoDemon is correct.")
        Message "File not found."
        mType = vbExclamation + vbOKOnly + vbApplicationModal
        
    'Unknown error
    Else
        AddInfo = g_Language.TranslateMessage("PhotoDemon cannot locate additional information for this error.  That probably means this error is a bug, and it needs to be fixed!" & vbCrLf & vbCrLf & "Would you like to submit a bug report?  (It takes less than one minute, and it helps everyone who uses the software.)")
        mType = vbCritical + vbYesNo + vbApplicationModal
        Message "Unknown error."
    End If
    
    'Create the message box to return the error information
    msgReturn = PDMsgBox("PhotoDemon has experienced an error.  Details on the problem include:" & vbCrLf & vbCrLf & "Error number %1" & vbCrLf & "Description: %2" & vbCrLf & vbCrLf & "%3", mType, "PhotoDemon Error Handler", Err.Number, Err.Description, AddInfo)
    
    'If the message box return value is "Yes", the user has opted to file a bug report.
    If msgReturn = vbYes Then
    
        'GitHub requires a login for submitting Issues; check for that first
        Dim secondaryReturn As VbMsgBoxResult
    
        secondaryReturn = PDMsgBox("Thank you for submitting a bug report.  To make sure your bug is addressed as quickly as possible, PhotoDemon needs you to answer one more question." & vbCrLf & vbCrLf & "Do you have a GitHub account? (If you have no idea what this means, answer ""No"".)", vbQuestion + vbApplicationModal + vbYesNo, "Thanks for making PhotoDemon better")
    
        'If they have a GitHub account, let them submit the bug there.  Otherwise, send them to the photodemon.org contact form
        If secondaryReturn = vbYes Then
            'Shell a browser window with the GitHub issue report form
            OpenURL "https://github.com/tannerhelland/PhotoDemon/issues/new"
            
            'Display one final message box with additional instructions
            PDMsgBox "PhotoDemon has automatically opened a GitHub bug report webpage for you.  In the Title box, please enter the following error number with a short description of the problem: %1" & vbCrLf & vbCrLf & "Any additional details you can provide in the large text box, including the steps that led up to this error, will help it get fixed as quickly as possible." & vbCrLf & vbCrLf & "When finished, click the Submit New Issue button.  Thank you!", vbInformation + vbApplicationModal + vbOKOnly, "GitHub bug report instructions", Err.Number
            
        Else
            'Shell a browser window with the photodemon.org contact form
            OpenURL "http://photodemon.org/about/contact/"
            
            'Display one final message box with additional instructions
            PDMsgBox "PhotoDemon has automatically opened a bug report webpage for you.  In the Comment box, please describe the steps that led to this error." & vbCrLf & vbCrLf & "Also in that box, please include the following error number: %1" & vbCrLf & vbCrLf & "When finished, click the Submit button.  Thank you!", vbInformation + vbApplicationModal + vbOKOnly, "Bug report instructions", Err.Number
            
        End If
    
    End If
        
End Sub

'Any internal structures that need to be generated can do so here.
Public Sub InitializeProcessor()
    
    'Reset all non-destructive request tracking data
    prevTextLayerID = -1
    ReDim prevGenericSetting(NUM_OF_GENERIC_PROPERTY_ENUMS) As Variant
    ReDim prevTextSetting(NUM_OF_TEXT_PROPERTY_ENUMS) As Variant
    ReDim prevNDFXSetting(NUM_OF_NDFX_PROPERTY_ENUMS) As Variant
    
End Sub

'I'm now testing a better method for tracking non-destructive changes to image settings.

'When a control tied to a non-destructive layer effect receives focus, it should call this function with its current value (translated
' as appropriate).  This function will make a note of that value, which can easily be compared when the control loses focus.
Public Sub flagInitialNDFXState_Generic(ByVal layerSettingID As PDLAYER_GENERIC_PROPERTY, ByVal layerSettingValue As Variant, ByVal targetLayerID As Long)
    
    'Debug messages can be helpful with this function
    'Debug.Print "ENTRANCE -- LayerSettingID: " & layerSettingID & ", LayerSettingValue: " & layerSettingValue
    
    'This function is easy; just store the values we are passed
    prevGenericSetting(layerSettingID) = layerSettingValue
    
    'As a failsafe against layer changes occurring simultaneous with focus changes, also make a note of the current layer.
    If prevGenericLayerID <> targetLayerID Then prevGenericLayerID = targetLayerID
    
End Sub

'When a control tied to a non-destructive layer effect loses focus, it should call this function with its current value (translated
' as appropriate).  This function will compare the value against its previously stored value, and if the two do not match, this function
' will add an Undo entry and notify the macro recorder (if active).
Public Sub flagFinalNDFXState_Generic(ByVal layerSettingID As PDLAYER_GENERIC_PROPERTY, ByVal layerSettingValue As Variant)
    
    'Debug messages can be helpful with this function
    'Debug.Print "EXIT -- LayerSettingID: " & layerSettingID & ", LayerSettingValue: " & layerSettingValue
    
    'Ignore all requests if no images are loaded
    If g_OpenImageCount = 0 Then Exit Sub
    
    'See if the new setting value differs.  If it does, we need to update the Undo/Redo chain and the Macro recorder list
    ' (if they're currently being recorded, obviously)
    If StrComp(CStr(layerSettingValue), CStr(prevGenericSetting(layerSettingID)), vbBinaryCompare) <> 0 Then
        
        'Raise a generic "layer setting change" processor request
        MiniProcess_NDFXOnly "Modify layer", , buildParams(layerSettingID, layerSettingValue), UNDO_LAYERHEADER, , , prevGenericLayerID
        
    End If
    
End Sub

'When a control tied to a non-destructive text effect receives focus, it should call this function with its current value (translated
' as appropriate).  This function will make a note of that value, which can easily be compared when the control loses focus.
Public Sub flagInitialNDFXState_Text(ByVal textSettingID As PD_TEXT_PROPERTY, ByVal textSettingValue As Variant, ByVal targetLayerID As Long)
    
    'This function is easy; just store the values we are passed
    prevTextSetting(textSettingID) = textSettingValue
    
    'As a failsafe against layer changes occurring simultaneous with focus changes, also make a note of the current layer.
    If prevTextLayerID <> targetLayerID Then prevTextLayerID = targetLayerID
    
End Sub

'When a control tied to a non-destructive text effect loses focus, it should call this function with its current value (translated
' as appropriate).  This function will compare the value against its previously stored value, and if the two do not match, this
' function will add an Undo entry and notify the macro recorder (if active).
Public Sub flagFinalNDFXState_Text(ByVal textSettingID As PD_TEXT_PROPERTY, ByVal textSettingValue As Variant)
    
    'Ignore all requests if no images are loaded
    If g_OpenImageCount = 0 Then Exit Sub
    
    'See if the new setting value differs.  If it does, we need to update the Undo/Redo chain and the Macro recorder list
    ' (if they're currently being recorded, obviously)
    If StrComp(CStr(textSettingValue), CStr(prevTextSetting(textSettingID)), vbBinaryCompare) <> 0 Then
        
        'Raise a generic "text setting change" processor request
        MiniProcess_NDFXOnly "Modify text layer", , buildParams(textSettingID, textSettingValue), UNDO_LAYER_VECTORSAFE, , , prevTextLayerID
        
    End If
    
End Sub

'Same as above, but for actual non-destructive image processing effects
Public Sub flagInitialNDFXState_NDFX(ByVal ndfxSettingID As LAYER_NONDESTRUCTIVE_FX, ByVal ndfxSettingValue As Variant, ByVal targetLayerID As Long)
    
    'This function is easy; just store the values we are passed
    prevNDFXSetting(ndfxSettingID) = ndfxSettingValue
    
    'As a failsafe against layer changes occurring simultaneous with focus changes, also make a note of the current layer.
    If prevNDFXLayerID <> targetLayerID Then prevNDFXLayerID = targetLayerID
    
End Sub

Public Sub flagFinalNDFXState_NDFX(ByVal ndfxSettingID As LAYER_NONDESTRUCTIVE_FX, ByVal ndfxSettingValue As Variant)
    
    'Ignore all requests if no images are loaded
    If g_OpenImageCount = 0 Then Exit Sub
    
    'See if the new setting value differs.  If it does, we need to update the Undo/Redo chain and the Macro recorder list
    ' (if they're currently being recorded, obviously)
    If StrComp(CStr(ndfxSettingValue), CStr(prevNDFXSetting(ndfxSettingID)), vbBinaryCompare) <> 0 Then
        
        'Raise a generic "layer setting change" processor request
        MiniProcess_NDFXOnly "Non-destructive effect", , buildParams(ndfxSettingID, ndfxSettingValue), UNDO_LAYERHEADER, , , prevGenericLayerID
        
    End If
    
End Sub

'Micro processor to be used ONLY for non-destructive FX.  I have deliberately declared it as private to avoid using it elsewhere.
Private Sub MiniProcess_NDFXOnly(ByVal processID As String, Optional showDialog As Boolean = False, Optional processParameters As String = "", Optional createUndo As PD_UNDO_TYPE = UNDO_NOTHING, Optional relevantTool As Long = -1, Optional recordAction As Boolean = True, Optional ByVal targetLayerID As Long = -1)

    'Mark the software processor as busy, but only if we're not showing a dialog.
    If Not showDialog Then m_Processing = True
    
    'If no layer is specified, assume we're operating on the currently active layer
    If targetLayerID = -1 Then targetLayerID = pdImages(g_CurrentImage).getActiveLayerID
    
    'If the macro recorder is running and this action is marked as recordable, store it in our running stack of processor calls
    If (MacroStatus = MacroSTART) And recordAction Then
    
        'Increase the process count
        ProcessCount = ProcessCount + 1
        
        'Copy the current process's information into the tracking array
        ReDim Preserve Processes(0 To ProcessCount) As ProcessCall
        
        With Processes(ProcessCount)
            .Id = processID
            .Dialog = showDialog
            .Parameters = processParameters
            .MakeUndo = createUndo
            .Tool = relevantTool
            .Recorded = recordAction
        End With
        
    End If
    
    'If a dialog is being displayed, forcibly disable Undo creation
    If showDialog Then createUndo = UNDO_NOTHING
    
    'Finally, create a parameter parser to handle the parameter string.  This class will parse out individual parameters
    ' as specific data types when it comes time to use them.
    Dim cParams As pdParamString
    Set cParams = New pdParamString
    If Len(processParameters) <> 0 Then cParams.setParamString processParameters
    
    'Perform the actual command processing.
    '
    'Note that in most cases, the command will have already been processed, so we don't actually need to do any further image processing.
    ' Instead, we typically just append some extra text to the operation name (e.g. "Modify layer" becomes "Modify layer name") so we can
    ' supply more helpful Undo/Redo text to the user.
    Select Case processID
    
        Case "Modify layer"
            processID = processID & " " & getNameOfGenericAction(cParams.GetLong(1))
        
        Case "Modify text layer"
            processID = processID & " " & getNameOfTextAction(cParams.GetLong(1))
            
        Case "Non-destructive effect"
            processID = processID & " (" & getNameOfNDFXAction(cParams.GetLong(1)) & ")"
        
        Case Else
            Debug.Print "WARNING!  Unknown processID submitted to MiniProcess_NDFXOnly().  Fix it!"
    
    End Select
    
    'TODO!  Mimic these requests inside the main processor, so Macro playback has a place to trigger the behavior
    
    
    'If the image has been modified and we are not performing a batch conversion (disabled to save speed!), redraw form and taskbar icons,
    ' as well as the image tab-bar.
    If (createUndo <> UNDO_NOTHING) And (MacroStatus <> MacroBATCH) And (Not pdImages(g_CurrentImage) Is Nothing) Then
        createCustomFormIcon pdImages(g_CurrentImage)
        toolbar_ImageTabs.notifyUpdatedImage g_CurrentImage
        
        'TODO: notify the layer toolbox of the change, so it can generate a new thumbnail
        
    End If
    
    'Generally, we assume that actions want us to create Undo data for them.  However, there are a few known exceptions:
    ' 1) If this processor request was just for displaying a dialog
    ' 2) If macro recording has been disabled for this action.  (This is typically used when an internal PD function
    '     utilizes other functions, but we only want a single Undo point created for the full set of actions.)
    ' 3) If we are in the midst of playing back a recorded macro (Undo data takes extra time to process, so we ignore it
    '     during macro playback)
    If (createUndo <> UNDO_NOTHING) And (MacroStatus <> MacroBATCH) And (Not showDialog) And recordAction And (Not pdImages(g_CurrentImage) Is Nothing) Then
    
        'An Undo file should be created.  In most cases, the parameters used are automatic (e.g. the image's active layer is
        ' assumed as the target, etc).  In some rare cases, however, we may need to supply custom parameters to the Undo engine.
        ' Check for those now.
        Dim affectedLayerID As Long
        affectedLayerID = targetLayerID
        
        'Create the Undo data; note that this line uniquely notifies the undo manager that it is allowed to coalesce identical
        ' processID requests.
        pdImages(g_CurrentImage).undoManager.createUndoData processID, processParameters, createUndo, affectedLayerID, relevantTool, True
        
    End If
    
    'Synchronize *only* Undo/Redo related elements
    Interface.SyncUndoRedoInterfaceElements
    
    'Mark the processor as ready
    m_Processing = False
    
End Sub

Private Function getNameOfGenericAction(ByVal genericSettingID As PDLAYER_GENERIC_PROPERTY) As String
    
    Select Case genericSettingID
        
        Case pgp_Name
            getNameOfGenericAction = g_Language.TranslateMessage("name")
        
        Case pgp_GroupID
            getNameOfGenericAction = g_Language.TranslateMessage("group")
        
        Case pgp_Opacity
            getNameOfGenericAction = g_Language.TranslateMessage("opacity")
        
        Case pgp_BlendMode
            getNameOfGenericAction = g_Language.TranslateMessage("blend mode")
        
        Case pgp_OffsetX
            getNameOfGenericAction = g_Language.TranslateMessage("X offset")
        
        Case pgp_OffsetY
            getNameOfGenericAction = g_Language.TranslateMessage("Y offset")
        
        Case pgp_CanvasXModifier
            getNameOfGenericAction = g_Language.TranslateMessage("width")
        
        Case pgp_CanvasYModifier
            getNameOfGenericAction = g_Language.TranslateMessage("height")
        
        Case pgp_Angle
            getNameOfGenericAction = g_Language.TranslateMessage("angle")
        
        Case pgp_Visibility
            getNameOfGenericAction = g_Language.TranslateMessage("visibility")
        
        Case pgp_NonDestructiveFXActive
            getNameOfGenericAction = g_Language.TranslateMessage("non-destructive effect")
        
        Case pgp_ResizeQuality
            getNameOfGenericAction = g_Language.TranslateMessage("resize quality")
        
    End Select
    
End Function

Private Function getNameOfTextAction(ByVal textSettingID As PD_TEXT_PROPERTY) As String
    
    Select Case textSettingID
        
        Case ptp_Text
            getNameOfTextAction = g_Language.TranslateMessage("text")
        
        Case ptp_FontColor
            getNameOfTextAction = g_Language.TranslateMessage("font (color)")
        
        Case ptp_FontFace
            getNameOfTextAction = g_Language.TranslateMessage("font (face)")
        
        Case ptp_FontSize
            getNameOfTextAction = g_Language.TranslateMessage("font (size)")
        
        Case ptp_FontSizeUnit
            getNameOfTextAction = g_Language.TranslateMessage("font (size unit)")
        
        Case ptp_FontBold
            getNameOfTextAction = g_Language.TranslateMessage("style (bold)")
        
        Case ptp_FontItalic
            getNameOfTextAction = g_Language.TranslateMessage("style (italic)")
        
        Case ptp_FontUnderline
            getNameOfTextAction = g_Language.TranslateMessage("style (underline)")
        
        Case ptp_FontStrikeout
            getNameOfTextAction = g_Language.TranslateMessage("style (strikeout)")
        
        Case ptp_HorizontalAlignment
            getNameOfTextAction = g_Language.TranslateMessage("horizontal alignment")
        
        Case ptp_VerticalAlignment
            getNameOfTextAction = g_Language.TranslateMessage("vertical alignment")
        
        Case ptp_TextAntialiasing
            getNameOfTextAction = g_Language.TranslateMessage("antialiasing")
        
        Case ptp_TextContrast
            getNameOfTextAction = g_Language.TranslateMessage("antialiasing clarity")
    
    End Select
    
End Function

Private Function getNameOfNDFXAction(ByVal ndfxSettingID As LAYER_NONDESTRUCTIVE_FX) As String
    
    Select Case ndfxSettingID
        
        Case NDFX_EXPOSURE
            getNameOfNDFXAction = g_Language.TranslateMessage("exposure")
        
        Case NDFX_CONTRAST
            getNameOfNDFXAction = g_Language.TranslateMessage("contrast")
            
        Case NDFX_CLARITY
            getNameOfNDFXAction = g_Language.TranslateMessage("clarity")
            
        Case NDFX_VIBRANCE
            getNameOfNDFXAction = g_Language.TranslateMessage("vibrance")
            
        Case NDFX_TEMPERATURE
            getNameOfNDFXAction = g_Language.TranslateMessage("temperature")
            
        Case NDFX_TINT
            getNameOfNDFXAction = g_Language.TranslateMessage("tint")
        
    End Select
    
End Function

'Mark PD as busy or not-busy.  This function should only be used for behavior that falls outside the purvue of the main Processor() function.
'
'NOTE: It is VERY IMPORTANT that you call this function in pairs, with special attention given to things like unexpected
' error-trap returns.  You will break PD if you mark it as busy and then never release the busy state.
'NOTE: The optional "changeCursor" boolean can be used to apply a busy cursor if you are marking the program as busy.  That parameter
' is ignored when marking the program as NOT busy, so the caller doesn't have to worry about resetting it correctly.
Public Sub MarkProgramBusyState(ByVal newState As Boolean, Optional ByVal changeCursor As Boolean = False)

    If newState Then
        
        m_Processing = True
        
        'Make a note of the window that has keyboard focus, then forcibly remove it
        m_FocusHWnd = g_WindowManager.GetFocusAPI()
        If m_FocusHWnd <> 0 Then g_WindowManager.SetFocusAPI 0&
        
        'Change the cursor to a busy state (but ONLY if explicitly requested - this is important)
        If changeCursor Then Screen.MousePointer = vbHourglass
        
        'This function mostly wraps the corresponding function in the Interface sub, but with a few extra cases covered.
        Interface.DisableUserInput
        
        'Temporarily disable drag-and-drop operations for the main form while external actions are processing
        g_AllowDragAndDrop = False
        FormMain.OLEDropMode = 0
        
    Else
        
        m_Processing = False
        Interface.EnableUserInput
        
        'Always reset the cursor to match, regardless of the passed cursor state
        Screen.MousePointer = vbDefault
        
        'Re-enable drag and drop operations
        g_AllowDragAndDrop = True
        FormMain.OLEDropMode = 1
        
        'Restore keyboard focus to whichever control had it previously
        If m_FocusHWnd <> 0 Then g_WindowManager.SetFocusAPI m_FocusHWnd
        
    End If

End Sub

Public Function IsProgramBusy() As Boolean
    IsProgramBusy = m_Processing
End Function
